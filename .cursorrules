# Cursor Rules for runi

## Ralph File Management

When working with Ralph documentation files, use these commands:

### CLI Commands (Chainable, Recommended for Automation)

```bash
# Normalize files
just normalize-ralph

# Validate consistency
just validate-ralph

# Heal files with prompt
just heal-ralph "your healing prompt here"
just heal-ralph --prompt-file prompts/heal-request.md
just heal-ralph --dry-run "preview changes"

# Clean session
just clean-ralph
```

## File Discovery

Ralph files are discovered dynamically:

- Core files: `@fix_plan.md`, `specs/requirements.md`, `PROMPT.md`, `CLAUDE.md`
- All `prompts/*.md` files (automatically found)
- No hardcoded file lists - adapts to project structure

**Planning Documents:** Strategic planning documents are in a separate repository accessed via MCP tools. Use `mcp_runi_Planning_read_doc` to read planning documents. See `CLAUDE.md` for references to planning docs.

---

## Core Architectural Patterns

These patterns apply across all layers and enable MCP-driven UI, loose coupling, and testability.

### Event-Driven Architecture (Pub/Sub)

**Purpose**: Enable MCP/AI-driven UI, loose component coupling

**Rules**:

- Use `src/events/bus.ts` EventBus for all cross-component communication
- Components emit events instead of calling other components directly
- UI can be driven by AI/MCP by emitting events to the bus
- Components subscribe to events they care about
- No direct component-to-component dependencies for cross-cutting concerns

**Example**: Sidebar position changes emit `sidebar.position-changed`, layout subscribes

### Loose Coupling / High Cohesion

**Purpose**: Enable fluid layout changes (sidebar left/right), pluggable components

**Rules**:

- Components should not depend on specific layout positions
- Sidebar position should be configuration-driven, not hardcoded
- Components communicate via events or props, never direct references
- Each component should have a single, well-defined responsibility

**Anti-patterns**: Hardcoding sidebar position (e.g., `left-0` in layout), direct component imports in unrelated modules

### Configuration-Driven Layout

**Purpose**: Enable runtime layout changes (sidebar left/right), theme switching, feature flags

**Rules**:

- Layout positions, dimensions, and visibility should be in state/store, not hardcoded
- Use settings store or configuration objects for layout decisions
- Layout components should be position-agnostic (can render left or right based on config)

**Current Gap**: `MainLayout.tsx` hardcodes sidebar on left; should support `sidebarPosition: 'left' | 'right'` in settings

### MCP Integration Patterns

**Purpose**: Enable AI-driven UI via MCP protocol

**Rules**:

- AI/MCP layer emits events to event bus (e.g., `ai.suggestion-available`, `ai.ui-command`)
- UI components subscribe to AI events and react accordingly
- AI commands should be declarative (e.g., `{ type: 'move-sidebar', position: 'right' }`)
- Keep AI logic isolated in adapters, core UI remains framework-agnostic

**Future**: MCP adapter will translate MCP commands to event bus events

### Ports and Adapters (Hexagonal Architecture)

**Purpose**: Isolate core logic from UI/infrastructure, enable swapping implementations

**Rules**:

- Core domain logic (Rust backend) should not depend on UI details
- Tauri commands act as adapters between React UI (port) and Rust logic (adapter)
- AI providers (Ollama, Claude) should be swappable via interfaces
- Storage, network, and UI are all adapters to the core domain

### Unidirectional Data Flow

**Purpose**: Predictable state updates, easier debugging (especially AI-driven changes)

**Rules**:

- State flows down via props, events flow up via event bus or callbacks
- Use Zustand stores for global state, `useState` for local state
- Avoid bidirectional data binding or circular dependencies
- State changes should be traceable (events → actions → state → UI)

### Testability Requirements

**Purpose**: Ensure components are testable and behavior is understood

**Rules**:

- Components should have clear, testable contracts (props, events)
- Use dependency injection to enable mocking (event bus, stores, Tauri commands)
- Tests should verify behavior (what component does) not implementation (how it does it)
- **TDD Mandate**: Write tests first to define behavior, then implement

---

## Frontend Patterns (React/TypeScript in `src/`)

These patterns apply when working in the React frontend.

### Container/Presentational Component Separation

**Purpose**: Enable testable, reusable UI components

**Rules**:

- **Presentational components**: Pure rendering, props in, JSX out, no side effects
- **Container components** (or hooks): Handle state, events, side effects, orchestration
- Presentational components are easily testable in isolation
- Containers handle event bus subscriptions, Tauri commands, state management

**Example**: `<Sidebar />` should be presentational; `<MainLayout />` is container that orchestrates

### Inversion of Control / Dependency Injection

**Purpose**: Enable testability, swappable implementations, flexible layouts

**Rules**:

- Dependencies should be injected (via props, hooks, or context) rather than imported directly
- Core logic should depend on abstractions (interfaces) not concrete implementations
- UI components should receive renderers, strategies, or configuration as props

**Example**: Layout components receive sidebar position/config as props, not hardcoded constants

### Component Composition Over Inheritance

**Purpose**: Enable flexible UI composition, avoid rigid hierarchies

**Rules**:

- Compose components via props.children or render props
- Avoid deep component hierarchies or inheritance
- Layout components should accept children, not hardcode structure
- Use composition to build complex UIs from simple, reusable pieces

---

## Backend Patterns (Rust/Tauri in `src-tauri/`)

These patterns apply when working in the Rust backend.

### Dependency Injection / Inversion of Control

**Purpose**: Enable testability, swappable implementations (Ollama vs Claude)

**Rules**:

- Dependencies should be injected via traits (interfaces), not concrete types
- Core domain logic should depend on trait abstractions, not concrete implementations
- Use dependency injection for services (HTTP client, storage, AI providers)

**Example**: HTTP client trait allows swapping implementations for testing

### Ports and Adapters Pattern

**Purpose**: Isolate core domain from infrastructure

**Rules**:

- Domain logic should not depend on Tauri, file system, or network directly
- Tauri commands are adapters that translate between UI (port) and domain (adapter)
- Storage, network, and AI providers are all adapters implementing domain traits
- Core domain remains framework-agnostic

---

## Architectural Violations (Must Fix in Code Reviews)

- Hardcoded layout positions (sidebar left/right)
- Direct component dependencies for cross-cutting concerns
- Missing event bus usage for component communication
- Tight coupling between unrelated components
- Configuration values hardcoded instead of in store/config

## Architectural Improvements (Should Fix in Code Reviews)

- Components not following Container/Presentational pattern
- State management not following unidirectional flow
- Dependencies not injected (direct imports)
- Layout components not position-agnostic
