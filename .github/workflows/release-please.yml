name: Release Please

on:
  workflow_run:
    workflows: ['CI']
    types:
      - completed
    branches:
      - main
  workflow_dispatch:
    inputs:
      skip_ci_check:
        description: 'Skip CI status check (use with caution)'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  check-ci-status:
    name: Verify CI Workflow Passed
    runs-on: ubuntu-latest
    outputs:
      ci-passed: ${{ steps.check.outputs.ci-passed }}
    steps:
      - name: Check CI workflow status or set default
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            if (context.eventName === 'workflow_run') {
              const workflowRun = context.payload.workflow_run;
              
              if (workflowRun.conclusion !== 'success') {
                core.setOutput('ci-passed', 'false');
                core.setFailed(`CI workflow did not pass. Conclusion: ${workflowRun.conclusion}`);
              } else {
                core.setOutput('ci-passed', 'true');
              }
            } else {
              // Manual trigger - check if user explicitly skipped CI check
              const skipCiCheck = context.payload.inputs?.skip_ci_check === 'true';
              if (skipCiCheck) {
                core.setOutput('ci-passed', 'true');
                core.warning('CI check skipped by user - proceeding with release-please');
              } else {
                // For manual triggers without skip flag, check latest CI status
                const { data: workflows } = await github.rest.actions.listWorkflowRuns({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: 'ci.yml',
                  branch: 'main',
                  per_page: 1
                });
                
                if (workflows.workflow_runs.length > 0) {
                  const latestRun = workflows.workflow_runs[0];
                  if (latestRun.conclusion === 'success') {
                    core.setOutput('ci-passed', 'true');
                  } else {
                    core.setOutput('ci-passed', 'false');
                    core.setFailed(`Latest CI workflow did not pass. Conclusion: ${latestRun.conclusion}. Use skip_ci_check input to bypass.`);
                  }
                } else {
                  core.setOutput('ci-passed', 'false');
                  core.setFailed('No CI workflow runs found. Use skip_ci_check input to bypass.');
                }
              }
            }

  release-please:
    name: Create Release PR
    runs-on: ubuntu-latest
    needs: check-ci-status
    if: needs.check-ci-status.outputs.ci-passed == 'true'
    outputs:
      release_created: ${{ steps.final-outputs.outputs.release_created }}
      tag_name: ${{ steps.final-outputs.outputs.tag_name }}
      changelog: ${{ steps.final-outputs.outputs.changelog }}
      merge_commit: ${{ steps.final-outputs.outputs.merge_commit }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha || github.ref }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Run release-please (manages PRs only)
        uses: googleapis/release-please-action@v4
        id: release
        with:
          config-file: release-please-config.json

      - name: Detect merged release PR and prepare release
        id: detect-release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Strategy: Look for recently merged release PRs by searching commit history
          # We search for merge commits with pattern "chore(main): release runi X.Y.Z"
          # This is more reliable than relying on manifest version which may have been updated

          echo "Searching for recently merged release PRs..."

          # Find all merge commits matching release PR pattern from last 50 commits
          # Format: "chore(main): release runi X.Y.Z (#PR)"
          RELEASE_COMMITS=$(git log --grep="chore(main): release runi" --format="%H|%s" -n 50 | grep -E "chore\(main\): release runi [0-9]+\.[0-9]+\.[0-9]+")

          if [ -z "$RELEASE_COMMITS" ]; then
            echo "No release PR merge commits found"
            echo "tag_name=" >> $GITHUB_OUTPUT
            echo "release_created=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Process each release commit to find one without a tag
          FOUND_RELEASE=false
          while IFS='|' read -r COMMIT_SHA COMMIT_MSG; do
            # Extract version from commit message: "chore(main): release runi 0.3.0 (#76)"
            VERSION=$(echo "$COMMIT_MSG" | sed -nE 's/.*release runi ([0-9]+\.[0-9]+\.[0-9]+).*/\1/p')
            
            if [ -z "$VERSION" ]; then
              continue
            fi
            
            TAG_NAME="runi-v${VERSION}"
            
            echo "Checking version $VERSION (tag: $TAG_NAME) at commit $COMMIT_SHA"
            
            # Check if tag already exists
            if gh api "repos/${{ github.repository }}/git/ref/tags/$TAG_NAME" >/dev/null 2>&1; then
              echo "Tag $TAG_NAME already exists, skipping"
              continue
            fi
            
            # Check if GitHub release already exists
            if gh release view "$TAG_NAME" >/dev/null 2>&1; then
              echo "Release $TAG_NAME already exists, skipping"
              continue
            fi
            
            # Found a release PR that was merged but has no tag/release
            echo "✅ Found merged release PR for $VERSION at $COMMIT_SHA"
            echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
            echo "release_created=true" >> $GITHUB_OUTPUT
            echo "merge_commit=$COMMIT_SHA" >> $GITHUB_OUTPUT
            FOUND_RELEASE=true
            break
            
          done <<< "$RELEASE_COMMITS"

          if [ "$FOUND_RELEASE" = "false" ]; then
            echo "No untagged release PRs found"
            echo "tag_name=" >> $GITHUB_OUTPUT
            echo "release_created=false" >> $GITHUB_OUTPUT
          fi

      - name: Extract changelog for release
        id: changelog
        if: steps.detect-release.outputs.release_created == 'true'
        run: |
          if [ -f "CHANGELOG.md" ]; then
            # Extract the latest changelog entry (from first ## header to next ## or end of file)
            CHANGELOG=$(awk 'BEGIN{in_section=0} /^## /{ if (in_section) exit; in_section=1 } in_section' CHANGELOG.md)
            # Escape for multiline output
            echo "changelog<<EOF" >> $GITHUB_OUTPUT
            echo "$CHANGELOG" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi

      - name: Set outputs
        id: final-outputs
        run: |
          echo "release_created=${{ steps.detect-release.outputs.release_created }}" >> $GITHUB_OUTPUT
          echo "tag_name=${{ steps.detect-release.outputs.tag_name }}" >> $GITHUB_OUTPUT
          echo "merge_commit=${{ steps.detect-release.outputs.merge_commit }}" >> $GITHUB_OUTPUT
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "${{ steps.changelog.outputs.changelog }}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  create-tag:
    name: Create Release Tag
    needs: [check-ci-status, release-please]
    if: |
      needs.release-please.outputs.release_created == 'true' &&
      needs.check-ci-status.outputs.ci-passed == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha || github.ref }}
          fetch-depth: 0

      - name: Create release tag
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG_NAME="${{ needs.release-please.outputs.tag_name }}"
          MERGE_COMMIT="${{ needs.release-please.outputs.merge_commit }}"

          if [ -z "$MERGE_COMMIT" ]; then
            echo "::error::Merge commit not found for tag $TAG_NAME"
            exit 1
          fi

          # Check if tag already exists
          if gh api "repos/${{ github.repository }}/git/ref/tags/$TAG_NAME" >/dev/null 2>&1; then
            echo "Tag $TAG_NAME already exists, skipping creation"
          else
            echo "Creating tag: $TAG_NAME at $MERGE_COMMIT"
            
            # Create the tag
            gh api repos/${{ github.repository }}/git/refs \
              -X POST \
              -f ref="refs/tags/$TAG_NAME" \
              -f sha="$MERGE_COMMIT"
            
            echo "✅ Created tag $TAG_NAME"
          fi

  build:
    name: Build ${{ matrix.os }}
    needs: [check-ci-status, release-please, create-tag]
    if: |
      needs.release-please.outputs.release_created == 'true' &&
      needs.check-ci-status.outputs.ci-passed == 'true' &&
      needs.create-tag.result == 'success'
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest]
    env:
      CARGO_TERM_COLOR: always
    steps:
      - name: Checkout tagged release
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.release-please.outputs.tag_name }}

      - name: Install just
        uses: extractions/setup-just@v2

      - name: Install Linux dependencies
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Cache Rust dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            src-tauri/target/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Build Tauri app
        run: just build

      - name: Prepare release artifacts
        run: |
          # Create artifacts directory for this platform
          mkdir -p release-artifacts

          # Get version from package.json
          VERSION=$(node -p "require('./package.json').version")

          # Helper function to normalize architecture from filename or system
          # Normalizes arm64 -> aarch64, keeps x86_64/amd64 as x86_64
          detect_arch() {
            local filename="$1"
            local fallback_arch="$2"
            local arch=""

            # Try to detect from filename first
            if echo "$filename" | grep -qiE "aarch64|arm64"; then
              arch="aarch64"
            elif echo "$filename" | grep -qiE "x86_64|amd64"; then
              arch="x86_64"
            elif [ -n "$fallback_arch" ]; then
              # Normalize fallback architecture to canonical names
              case "$fallback_arch" in
                arm64) arch="aarch64" ;;
                x86_64|amd64) arch="x86_64" ;;
                *) arch="x86_64" ;; # Default
              esac
            else
              arch="x86_64" # Default
            fi

            echo "$arch"
          }

          # Copy and rename bundle files with descriptive names
          # Format: runi-{version}-{platform}-{architecture}.{ext}
          if [ -d "src-tauri/target/release/bundle" ]; then
            # Find and rename macOS DMG files
            find src-tauri/target/release/bundle -name "*.dmg" -type f | while read -r dmg; do
              ARCH=$(detect_arch "$dmg" "$(uname -m)")
              NEW_NAME="runi-${VERSION}-macos-${ARCH}.dmg"
              cp "$dmg" "release-artifacts/${NEW_NAME}"
              echo "Renamed: $(basename "$dmg") -> ${NEW_NAME}"
            done

            # Find and rename Linux DEB files
            find src-tauri/target/release/bundle -name "*.deb" -type f | while read -r deb; do
              ARCH=$(detect_arch "$deb" "x86_64")
              NEW_NAME="runi-${VERSION}-linux-${ARCH}.deb"
              cp "$deb" "release-artifacts/${NEW_NAME}"
              echo "Renamed: $(basename "$deb") -> ${NEW_NAME}"
            done

            # Find and rename Linux RPM files
            find src-tauri/target/release/bundle -name "*.rpm" -type f | while read -r rpm; do
              ARCH=$(detect_arch "$rpm" "x86_64")
              NEW_NAME="runi-${VERSION}-linux-${ARCH}.rpm"
              cp "$rpm" "release-artifacts/${NEW_NAME}"
              echo "Renamed: $(basename "$rpm") -> ${NEW_NAME}"
            done

            # Find and rename Linux AppImage files
            find src-tauri/target/release/bundle -name "*.AppImage" -type f | while read -r appimage; do
              ARCH=$(detect_arch "$appimage" "x86_64")
              NEW_NAME="runi-${VERSION}-linux-${ARCH}-portable.AppImage"
              cp "$appimage" "release-artifacts/${NEW_NAME}"
              echo "Renamed: $(basename "$appimage") -> ${NEW_NAME}"
            done

            # List all renamed artifacts
            echo "Release artifacts prepared:"
            ls -lh release-artifacts/ || true
          fi
        shell: bash

      - name: Check for artifacts
        id: check-artifacts
        run: |
          # Check for renamed artifacts with new naming pattern
          if ls release-artifacts/runi-*.dmg release-artifacts/runi-*.AppImage release-artifacts/runi-*.deb release-artifacts/runi-*.rpm 2>/dev/null | grep -q .; then
            echo "found=true" >> $GITHUB_OUTPUT
          else
            echo "found=false" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        if: steps.check-artifacts.outputs.found == 'true'
        with:
          name: release-artifacts-${{ matrix.os }}
          path: release-artifacts/*
          retention-days: 7

  create-release:
    name: Create Release with Artifacts
    needs: [check-ci-status, release-please, create-tag, build]
    if: |
      needs.release-please.outputs.release_created == 'true' &&
      needs.check-ci-status.outputs.ci-passed == 'true' &&
      needs.create-tag.result == 'success' &&
      needs.build.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          pattern: release-artifacts-*
          merge-multiple: true
          path: release-artifacts

      - name: Check if artifacts exist
        id: check-artifacts
        run: |
          if [ -d "release-artifacts" ] && [ "$(ls -A release-artifacts 2>/dev/null)" ]; then
            echo "found=true" >> $GITHUB_OUTPUT
            echo "Artifacts found:" >> $GITHUB_STEP_SUMMARY
            ls -lh release-artifacts/ >> $GITHUB_STEP_SUMMARY
          else
            echo "found=false" >> $GITHUB_OUTPUT
            echo "⚠️ No artifacts found" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Create GitHub Release with artifacts
        if: steps.check-artifacts.outputs.found == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.release-please.outputs.tag_name }}
          name: Release ${{ needs.release-please.outputs.tag_name }}
          body: ${{ needs.release-please.outputs.changelog }}
          files: |
            release-artifacts/*
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Warn if release skipped
        if: steps.check-artifacts.outputs.found == 'false'
        run: |
          echo "⚠️ Release skipped: No artifacts were built."
          exit 1
