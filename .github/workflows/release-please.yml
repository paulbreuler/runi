name: Release Please

on:
  workflow_run:
    workflows: ['CI']
    types:
      - completed
    branches:
      - main
  workflow_dispatch:
    inputs:
      skip_ci_check:
        description: 'Skip CI status check (use with caution)'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  check-ci-status:
    name: Verify CI Workflow Passed
    runs-on: ubuntu-latest
    outputs:
      ci-passed: ${{ steps.check.outputs.ci-passed }}
    steps:
      - name: Check CI workflow status or set default
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            if (context.eventName === 'workflow_run') {
              const workflowRun = context.payload.workflow_run;
              
              if (workflowRun.conclusion !== 'success') {
                core.setOutput('ci-passed', 'false');
                core.setFailed(`CI workflow did not pass. Conclusion: ${workflowRun.conclusion}`);
              } else {
                core.setOutput('ci-passed', 'true');
              }
            } else {
              // Manual trigger - check if user explicitly skipped CI check
              const skipCiCheck = context.payload.inputs?.skip_ci_check === 'true';
              if (skipCiCheck) {
                core.setOutput('ci-passed', 'true');
                core.warning('CI check skipped by user - proceeding with release-please');
              } else {
                // For manual triggers without skip flag, check latest CI status
                const { data: workflows } = await github.rest.actions.listWorkflowRuns({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: 'CI.yml',
                  branch: 'main',
                  per_page: 1
                });
                
                if (workflows.workflow_runs.length > 0) {
                  const latestRun = workflows.workflow_runs[0];
                  if (latestRun.conclusion === 'success') {
                    core.setOutput('ci-passed', 'true');
                  } else {
                    core.setOutput('ci-passed', 'false');
                    core.setFailed(`Latest CI workflow did not pass. Conclusion: ${latestRun.conclusion}. Use skip_ci_check input to bypass.`);
                  }
                } else {
                  core.setOutput('ci-passed', 'false');
                  core.setFailed('No CI workflow runs found. Use skip_ci_check input to bypass.');
                }
              }
            }

  release-please:
    name: Create Release PR
    runs-on: ubuntu-latest
    needs: check-ci-status
    if: needs.check-ci-status.outputs.ci-passed == 'true'
    outputs:
      release_created: ${{ steps.final-outputs.outputs.release_created }}
      tag_name: ${{ steps.final-outputs.outputs.tag_name }}
      changelog: ${{ steps.final-outputs.outputs.changelog }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha || github.ref }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Run release-please (skip release creation - we'll create it after artifacts are built)
        uses: googleapis/release-please-action@v4
        id: release
        with:
          config-file: release-please-config.json

      - name: Extract changelog for release
        id: changelog
        run: |
          if [ -f "CHANGELOG.md" ]; then
            # Extract the latest changelog entry (from first ## header to next ## or end of file)
            # Keep the version header and content, but stop at the next version section
            CHANGELOG=$(awk 'BEGIN{in_section=0} /^## /{ if (in_section) exit; in_section=1 } in_section' CHANGELOG.md)
            # Escape for multiline output
            echo "changelog<<EOF" >> $GITHUB_OUTPUT
            echo "$CHANGELOG" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi

      - name: Set outputs
        id: final-outputs
        run: |
          echo "release_created=${{ steps.release.outputs.release_created }}" >> $GITHUB_OUTPUT
          echo "tag_name=${{ steps.release.outputs.tag_name }}" >> $GITHUB_OUTPUT
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "${{ steps.changelog.outputs.changelog }}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  build:
    name: Build ${{ matrix.os }}
    needs: [check-ci-status, release-please]
    if: |
      needs.release-please.outputs.release_created == 'true' &&
      needs.check-ci-status.outputs.ci-passed == 'true'
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        # Only build for macOS since bundle targets are macOS-only (dmg, app)
        os: [macos-latest]
    env:
      CARGO_TERM_COLOR: always
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha || github.ref }}

      - name: Install just
        uses: extractions/setup-just@v2

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Cache Rust dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            src-tauri/target/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Build Tauri app
        run: just build

      - name: Prepare release artifacts
        run: |
          # Create artifacts directory for this platform
          mkdir -p release-artifacts

          # Get version from package.json
          VERSION=$(node -p "require('./package.json').version")

          # Helper function to normalize architecture from filename or system
          # Normalizes arm64 -> aarch64, keeps x86_64/amd64 as x86_64
          detect_arch() {
            local filename="$1"
            local fallback_arch="$2"
            local arch=""

            # Try to detect from filename first
            if echo "$filename" | grep -qiE "aarch64|arm64"; then
              arch="aarch64"
            elif echo "$filename" | grep -qiE "x86_64|amd64"; then
              arch="x86_64"
            elif [ -n "$fallback_arch" ]; then
              # Normalize fallback architecture to canonical names
              case "$fallback_arch" in
                arm64) arch="aarch64" ;;
                x86_64|amd64) arch="x86_64" ;;
                *) arch="x86_64" ;; # Default
              esac
            else
              arch="x86_64" # Default
            fi

            echo "$arch"
          }

          # Copy and rename bundle files with descriptive names
          # Format: runi-{version}-{platform}-{architecture}.{ext}
          if [ -d "src-tauri/target/release/bundle" ]; then
            # Find and rename macOS DMG files
            find src-tauri/target/release/bundle -name "*.dmg" -type f | while read -r dmg; do
              ARCH=$(detect_arch "$dmg" "$(uname -m)")
              NEW_NAME="runi-${VERSION}-macos-${ARCH}.dmg"
              cp "$dmg" "release-artifacts/${NEW_NAME}"
              echo "Renamed: $(basename "$dmg") -> ${NEW_NAME}"
            done

            # Find and rename Linux DEB files
            find src-tauri/target/release/bundle -name "*.deb" -type f | while read -r deb; do
              ARCH=$(detect_arch "$deb" "x86_64")
              NEW_NAME="runi-${VERSION}-linux-${ARCH}.deb"
              cp "$deb" "release-artifacts/${NEW_NAME}"
              echo "Renamed: $(basename "$deb") -> ${NEW_NAME}"
            done

            # Find and rename Linux RPM files
            find src-tauri/target/release/bundle -name "*.rpm" -type f | while read -r rpm; do
              ARCH=$(detect_arch "$rpm" "x86_64")
              NEW_NAME="runi-${VERSION}-linux-${ARCH}.rpm"
              cp "$rpm" "release-artifacts/${NEW_NAME}"
              echo "Renamed: $(basename "$rpm") -> ${NEW_NAME}"
            done

            # Find and rename Linux AppImage files
            find src-tauri/target/release/bundle -name "*.AppImage" -type f | while read -r appimage; do
              ARCH=$(detect_arch "$appimage" "x86_64")
              NEW_NAME="runi-${VERSION}-linux-${ARCH}-portable.AppImage"
              cp "$appimage" "release-artifacts/${NEW_NAME}"
              echo "Renamed: $(basename "$appimage") -> ${NEW_NAME}"
            done

            # List all renamed artifacts
            echo "Release artifacts prepared:"
            ls -lh release-artifacts/ || true
          fi
        shell: bash

      - name: Check for artifacts
        id: check-artifacts
        run: |
          # Check for renamed artifacts with new naming pattern
          if ls release-artifacts/runi-*.dmg release-artifacts/runi-*.AppImage release-artifacts/runi-*.deb release-artifacts/runi-*.rpm 2>/dev/null | grep -q .; then
            echo "found=true" >> $GITHUB_OUTPUT
          else
            echo "found=false" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        if: steps.check-artifacts.outputs.found == 'true'
        with:
          name: release-artifacts-${{ matrix.os }}
          path: release-artifacts/*
          retention-days: 7

  create-release:
    name: Create Release with Artifacts
    needs: [check-ci-status, release-please, build]
    if: |
      needs.release-please.outputs.release_created == 'true' &&
      needs.check-ci-status.outputs.ci-passed == 'true' &&
      needs.build.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          pattern: release-artifacts-*
          merge-multiple: true
          path: release-artifacts

      - name: Check if artifacts exist
        id: check-artifacts
        run: |
          if [ -d "release-artifacts" ] && [ "$(ls -A release-artifacts 2>/dev/null)" ]; then
            echo "found=true" >> $GITHUB_OUTPUT
            echo "Artifacts found:" >> $GITHUB_STEP_SUMMARY
            ls -lh release-artifacts/ >> $GITHUB_STEP_SUMMARY
          else
            echo "found=false" >> $GITHUB_OUTPUT
            echo "⚠️ No artifacts found" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Create GitHub Release with artifacts
        if: steps.check-artifacts.outputs.found == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.release-please.outputs.tag_name }}
          name: Release ${{ needs.release-please.outputs.tag_name }}
          body: ${{ needs.release-please.outputs.changelog }}
          files: |
            release-artifacts/*
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Warn if no artifacts
        if: steps.check-artifacts.outputs.found == 'false'
        run: |
          echo "⚠️ Release would be created but no artifacts were built. Skipping release creation."
          exit 1
