name: Release Please

on:
  workflow_run:
    workflows: ['CI']
    types:
      - completed
    branches:
      - main
      - dev
      - develop
  pull_request:
    types:
      - opened
      - synchronize
      - reopened
    branches:
      - main
      - dev
      - develop
  workflow_dispatch:
    inputs:
      skip_ci_check:
        description: 'Skip CI status check (use with caution)'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  check-ci-status:
    name: Verify CI Workflow Passed
    runs-on: ubuntu-latest
    outputs:
      ci-passed: ${{ steps.check.outputs.ci-passed }}
    steps:
      - name: Check CI workflow status or set default
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            if (context.eventName === 'workflow_run') {
              const workflowRun = context.payload.workflow_run;
              
              if (workflowRun.conclusion !== 'success') {
                core.setOutput('ci-passed', 'false');
                core.setFailed(`CI workflow did not pass. Conclusion: ${workflowRun.conclusion}`);
              } else {
                core.setOutput('ci-passed', 'true');
              }
            } else if (context.eventName === 'pull_request') {
              // For PRs, we're just validating the workflow - skip CI check
              core.setOutput('ci-passed', 'true');
              core.info('PR validation mode: Skipping CI check');
            } else {
              // Manual trigger - check if user explicitly skipped CI check
              const skipCiCheck = context.payload.inputs?.skip_ci_check === 'true';
              if (skipCiCheck) {
                core.setOutput('ci-passed', 'true');
                core.warning('CI check skipped by user - proceeding with release-please');
              } else {
                // For manual triggers without skip flag, check latest CI status
                const { data: workflows } = await github.rest.actions.listWorkflowRuns({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: 'ci.yml',
                  branch: 'main',
                  per_page: 1
                });
                
                if (workflows.workflow_runs.length > 0) {
                  const latestRun = workflows.workflow_runs[0];
                  if (latestRun.conclusion === 'success') {
                    core.setOutput('ci-passed', 'true');
                  } else {
                    core.setOutput('ci-passed', 'false');
                    core.setFailed(`Latest CI workflow did not pass. Conclusion: ${latestRun.conclusion}. Use skip_ci_check input to bypass.`);
                  }
                } else {
                  core.setOutput('ci-passed', 'false');
                  core.setFailed('No CI workflow runs found. Use skip_ci_check input to bypass.');
                }
              }
            }

  release-please:
    name: Create Release PR
    runs-on: ubuntu-latest
    needs: check-ci-status
    if: needs.check-ci-status.outputs.ci-passed == 'true'
    outputs:
      release_created: ${{ steps.final-outputs.outputs.release_created }}
      tag_name: ${{ steps.final-outputs.outputs.tag_name }}
      changelog: ${{ steps.final-outputs.outputs.changelog }}
      is_dev: ${{ steps.final-outputs.outputs.is_dev }}
      base_tag_name: ${{ steps.final-outputs.outputs.base_tag_name }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha || github.event.workflow_run.head_sha || github.ref }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Run release-please
        if: github.event_name != 'pull_request'
        uses: googleapis/release-please-action@v4
        id: release
        with:
          config-file: release-please-config.json

      - name: Set outputs for PR validation
        if: github.event_name == 'pull_request'
        id: final-outputs
        run: |
          echo "PR validation mode: Workflow syntax validated, skipping release operations"
          echo "release_created=false" >> $GITHUB_OUTPUT
          echo "tag_name=" >> $GITHUB_OUTPUT
          echo "changelog=" >> $GITHUB_OUTPUT

      - name: Detect branch type
        if: github.event_name != 'pull_request'
        id: branch-info
        run: |
          # Determine current branch
          if [ "${{ github.event_name }}" == "workflow_run" ]; then
            BRANCH="${{ github.event.workflow_run.head_branch }}"
          else
            BRANCH="${{ github.ref_name }}"
          fi

          echo "Current branch: $BRANCH"
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT

          # Check if this is a dev branch
          if [[ "$BRANCH" == "dev" ]] || [[ "$BRANCH" == "develop" ]] || [[ "$BRANCH" =~ ^dev/ ]]; then
            echo "is_dev=true" >> $GITHUB_OUTPUT
            echo "Dev branch detected: $BRANCH"
          else
            echo "is_dev=false" >> $GITHUB_OUTPUT
          fi

      - name: Set outputs for release
        if: github.event_name != 'pull_request'
        id: final-outputs
        run: |
          RELEASE_CREATED="${{ steps.release.outputs.release_created }}"
          BASE_TAG="${{ steps.release.outputs.tag_name }}"
          IS_DEV="${{ steps.branch-info.outputs.is_dev }}"

          # Modify tag name for dev branches
          if [ "$IS_DEV" == "true" ] && [ -n "$BASE_TAG" ]; then
            # Add -dev suffix to tag name (e.g., runi-v0.3.0 -> runi-v0.3.0-dev)
            TAG_NAME="${BASE_TAG}-dev"
            echo "Dev branch: Modified tag from $BASE_TAG to $TAG_NAME"
          else
            TAG_NAME="$BASE_TAG"
          fi

          echo "release_created=$RELEASE_CREATED" >> $GITHUB_OUTPUT
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "base_tag_name=$BASE_TAG" >> $GITHUB_OUTPUT
          echo "changelog=${{ steps.release.outputs.changelog }}" >> $GITHUB_OUTPUT
          echo "is_dev=$IS_DEV" >> $GITHUB_OUTPUT

      - name: Create dev tag and release if needed
        if: |
          github.event_name != 'pull_request' &&
          steps.final-outputs.outputs.is_dev == 'true' &&
          steps.final-outputs.outputs.release_created == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BASE_TAG="${{ steps.release.outputs.tag_name }}"
          DEV_TAG="${{ steps.final-outputs.outputs.tag_name }}"
          CHANGELOG="${{ steps.release.outputs.changelog }}"

          # Wait a moment for release-please to create the base tag
          sleep 2

          # Get the commit SHA that the base tag points to (or use current HEAD)
          if gh api "repos/${{ github.repository }}/git/ref/tags/$BASE_TAG" >/dev/null 2>&1; then
            TAG_SHA=$(gh api "repos/${{ github.repository }}/git/ref/tags/$BASE_TAG" --jq '.object.sha')
            echo "Base tag $BASE_TAG points to commit $TAG_SHA"
          else
            # If base tag doesn't exist yet, use the current HEAD
            TAG_SHA=$(git rev-parse HEAD)
            echo "Base tag $BASE_TAG not found, using current HEAD: $TAG_SHA"
          fi

          # Create dev tag if it doesn't exist
          if gh api "repos/${{ github.repository }}/git/ref/tags/$DEV_TAG" >/dev/null 2>&1; then
            echo "Dev tag $DEV_TAG already exists"
          else
            echo "Creating dev tag $DEV_TAG at commit $TAG_SHA"
            gh api repos/${{ github.repository }}/git/refs \
              -X POST \
              -f ref="refs/tags/$DEV_TAG" \
              -f sha="$TAG_SHA"
            echo "✅ Created dev tag $DEV_TAG"
          fi

          # Create or update dev release as prerelease with building message
          BUILDING_MSG=$'\n\n---\n\n⏳ **Artifacts are being built...**'
          RELEASE_NOTES="${CHANGELOG}${BUILDING_MSG}"

          if gh release view "$DEV_TAG" >/dev/null 2>&1; then
            echo "Dev release $DEV_TAG already exists, updating to prerelease"
            gh release edit "$DEV_TAG" --prerelease --notes "$RELEASE_NOTES"
          else
            echo "Creating dev release $DEV_TAG as prerelease"
            gh release create "$DEV_TAG" \
              --title "Release $DEV_TAG (Dev)" \
              --notes "$RELEASE_NOTES" \
              --prerelease
            echo "✅ Created dev release $DEV_TAG as prerelease"
          fi

      - name: Update release with building message
        if: |
          steps.final-outputs.outputs.release_created == 'true' &&
          github.event_name != 'pull_request' &&
          steps.final-outputs.outputs.is_dev != 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG_NAME="${{ steps.final-outputs.outputs.tag_name }}"

          # Get current release body
          CURRENT_BODY=$(gh release view "$TAG_NAME" --json body --jq '.body // ""')

          # Add building message if not already present
          if printf '%s\n' "$CURRENT_BODY" | grep -q "Artifacts are being built"; then
            echo "Building message already present"
          else
            # Use $'...' syntax for actual newlines
            BUILDING_MSG=$'\n\n---\n\n⏳ **Artifacts are being built...**'
            NEW_BODY="${CURRENT_BODY}${BUILDING_MSG}"
            
            gh release edit "$TAG_NAME" --notes "$NEW_BODY"
            echo "✅ Added building message to release"
          fi

  build:
    name: Build ${{ matrix.os }}
    needs: [check-ci-status, release-please]
    if: |
      needs.release-please.outputs.release_created == 'true' &&
      needs.check-ci-status.outputs.ci-passed == 'true'
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest]
    env:
      CARGO_TERM_COLOR: always
    steps:
      - name: Checkout tagged release
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.release-please.outputs.tag_name }}

      - name: Install just
        uses: extractions/setup-just@v2

      - name: Install Linux dependencies
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Cache Rust dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            src-tauri/target/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Build Tauri app
        run: just build

      - name: Prepare release artifacts
        run: |
          # Create artifacts directory for this platform
          mkdir -p release-artifacts

          # Get version from package.json
          VERSION=$(node -p "require('./package.json').version")

          # Helper function to normalize architecture from filename or system
          # Normalizes arm64 -> aarch64, keeps x86_64/amd64 as x86_64
          detect_arch() {
            local filename="$1"
            local fallback_arch="$2"
            local arch=""

            # Try to detect from filename first
            if echo "$filename" | grep -qiE "aarch64|arm64"; then
              arch="aarch64"
            elif echo "$filename" | grep -qiE "x86_64|amd64"; then
              arch="x86_64"
            elif [ -n "$fallback_arch" ]; then
              # Normalize fallback architecture to canonical names
              case "$fallback_arch" in
                arm64) arch="aarch64" ;;
                x86_64|amd64) arch="x86_64" ;;
                *) arch="x86_64" ;; # Default
              esac
            else
              arch="x86_64" # Default
            fi

            echo "$arch"
          }

          # Copy and rename bundle files with descriptive names
          # Format: runi-{version}-{platform}-{architecture}.{ext}
          if [ -d "src-tauri/target/release/bundle" ]; then
            # Find and rename macOS DMG files
            find src-tauri/target/release/bundle -name "*.dmg" -type f | while read -r dmg; do
              ARCH=$(detect_arch "$dmg" "$(uname -m)")
              NEW_NAME="runi-${VERSION}-macos-${ARCH}.dmg"
              cp "$dmg" "release-artifacts/${NEW_NAME}"
              echo "Renamed: $(basename "$dmg") -> ${NEW_NAME}"
            done

            # Find and rename Linux DEB files
            find src-tauri/target/release/bundle -name "*.deb" -type f | while read -r deb; do
              ARCH=$(detect_arch "$deb" "x86_64")
              NEW_NAME="runi-${VERSION}-linux-${ARCH}.deb"
              cp "$deb" "release-artifacts/${NEW_NAME}"
              echo "Renamed: $(basename "$deb") -> ${NEW_NAME}"
            done

            # Find and rename Linux RPM files
            find src-tauri/target/release/bundle -name "*.rpm" -type f | while read -r rpm; do
              ARCH=$(detect_arch "$rpm" "x86_64")
              NEW_NAME="runi-${VERSION}-linux-${ARCH}.rpm"
              cp "$rpm" "release-artifacts/${NEW_NAME}"
              echo "Renamed: $(basename "$rpm") -> ${NEW_NAME}"
            done

            # Find and rename Linux AppImage files
            find src-tauri/target/release/bundle -name "*.AppImage" -type f | while read -r appimage; do
              ARCH=$(detect_arch "$appimage" "x86_64")
              NEW_NAME="runi-${VERSION}-linux-${ARCH}-portable.AppImage"
              cp "$appimage" "release-artifacts/${NEW_NAME}"
              echo "Renamed: $(basename "$appimage") -> ${NEW_NAME}"
            done

            # List all renamed artifacts
            echo "Release artifacts prepared:"
            ls -lh release-artifacts/ || true
          fi
        shell: bash

      - name: Check for artifacts
        id: check-artifacts
        run: |
          # Check for renamed artifacts with new naming pattern
          if ls release-artifacts/runi-*.dmg release-artifacts/runi-*.AppImage release-artifacts/runi-*.deb release-artifacts/runi-*.rpm 2>/dev/null | grep -q .; then
            echo "found=true" >> $GITHUB_OUTPUT
          else
            echo "found=false" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        if: steps.check-artifacts.outputs.found == 'true'
        with:
          name: release-artifacts-${{ matrix.os }}
          path: release-artifacts/*
          retention-days: 7

  create-release:
    name: Upload Artifacts to Release
    needs: [check-ci-status, release-please, build]
    if: |
      needs.release-please.outputs.release_created == 'true' &&
      needs.check-ci-status.outputs.ci-passed == 'true' &&
      needs.build.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          pattern: release-artifacts-*
          merge-multiple: true
          path: release-artifacts

      - name: Check if artifacts exist
        id: check-artifacts
        run: |
          if [ -d "release-artifacts" ] && [ "$(ls -A release-artifacts 2>/dev/null)" ]; then
            echo "found=true" >> $GITHUB_OUTPUT
            echo "Artifacts found:" >> $GITHUB_STEP_SUMMARY
            ls -lh release-artifacts/ >> $GITHUB_STEP_SUMMARY
          else
            echo "found=false" >> $GITHUB_OUTPUT
            echo "⚠️ No artifacts found" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload artifacts and update release
        if: steps.check-artifacts.outputs.found == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG_NAME="${{ needs.release-please.outputs.tag_name }}"
          IS_DEV="${{ needs.release-please.outputs.is_dev }}"

          # For dev branches, use the dev tag; otherwise use the base tag
          if [ "$IS_DEV" == "true" ]; then
            RELEASE_TAG="$TAG_NAME"
            echo "Using dev tag for release: $RELEASE_TAG"
          else
            RELEASE_TAG="$TAG_NAME"
            echo "Using base tag for release: $RELEASE_TAG"
          fi

          # Get current release body (try dev tag first, fallback to base)
          CURRENT_BODY=""
          if gh release view "$RELEASE_TAG" >/dev/null 2>&1; then
            CURRENT_BODY=$(gh release view "$RELEASE_TAG" --json body --jq '.body // ""')
          elif [ "$IS_DEV" != "true" ] && gh release view "$TAG_NAME" >/dev/null 2>&1; then
            CURRENT_BODY=$(gh release view "$TAG_NAME" --json body --jq '.body // ""')
          fi

          # Remove building message section (everything from "---" onwards)
          # The building message format is: "\n\n---\n\n⏳ **Artifacts are being built...**"
          # Use awk to print lines until we hit "---", then stop
          NEW_BODY=$(printf '%s\n' "$CURRENT_BODY" | awk '/^---$/{exit} {print}')

          # Trim trailing newlines - use a more reliable approach
          # Remove trailing newlines while preserving content
          NEW_BODY=$(printf '%s\n' "$NEW_BODY" | sed -e :a -e '/^\n*$/{$d;N;ba' -e '}' | sed -e :a -e '$!{N;ba' -e '}' -e 's/\n*$//')

          # Upload artifacts to the appropriate release
          gh release upload "$RELEASE_TAG" release-artifacts/* --clobber

          # Update release body to remove building message
          # Use original changelog as fallback if body is empty
          if [ -z "$NEW_BODY" ]; then
            NEW_BODY="${{ needs.release-please.outputs.changelog }}"
          fi

          # Update release, marking as prerelease for dev branches
          if [ "$IS_DEV" == "true" ]; then
            gh release edit "$RELEASE_TAG" --notes "$NEW_BODY" --prerelease
            echo "✅ Artifacts uploaded to dev release $RELEASE_TAG (prerelease)"
          else
            gh release edit "$RELEASE_TAG" --notes "$NEW_BODY"
            echo "✅ Artifacts uploaded and release updated"
          fi

      - name: Warn if release skipped
        if: steps.check-artifacts.outputs.found == 'false'
        run: |
          echo "⚠️ Release skipped: No artifacts were built."
          exit 1
